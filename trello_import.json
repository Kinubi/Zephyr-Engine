{
  "name": "Zephyr Engine Development",
  "lists": [
    {
      "name": "ðŸš¨ High Priority / Next Up",
      "cards": [
        {
          "name": "Shadow Mapping",
          "desc": "Implement shadow mapping for rasterization path.\n\nCurrently NO shadows - scenes look flat and unrealistic. This is the single biggest visual quality improvement available.\n\nImplementation:\n1. Add ShadowMapPass to render graph (renders depth from light perspective)\n2. For PointLights: Use cube shadow maps (6 faces)\n3. For DirectionalLights (if added): Use Cascaded Shadow Maps\n4. Bind shadow maps in lighting shaders\n5. Sample shadow map and compare depth\n6. Add PCF (Percentage Closer Filtering) for soft edges\n\nConsider: Shadow atlas to batch multiple lights",
          "labels": ["Feature", "High Priority"]
        },
        {
          "name": "Undo/Redo System",
          "desc": "Implement Command pattern for editor actions.\n\nWithout undo, one wrong move requires manual fixing. Essential for usable content creation.\n\nImplementation:\n1. Create Command interface with execute() and undo()\n2. Implement commands:\n   - MoveEntityCommand (stores old/new transform)\n   - ChangePropertyCommand (stores old/new value)\n   - DeleteEntityCommand (stores full entity state)\n   - CreateEntityCommand\n   - ReparentEntityCommand\n3. Maintain undo/redo stacks in EditorApp\n4. Bind Ctrl+Z / Ctrl+Shift+Z (or Ctrl+Y)\n5. Show undo history in Edit menu",
          "labels": ["Feature", "Editor", "High Priority"]
        },
        {
          "name": "GLTF/GLB Import",
          "desc": "Add native GLTF/GLB model loading.\n\nOBJ is limited (no animations, poor materials). Real game assets use GLTF.\n\nImplementation:\n1. Integrate cgltf or write Zig parser\n2. Parse: nodes, meshes, materials, textures, animations, skins\n3. Convert to engine formats (Mesh, MaterialSet)\n4. Support embedded textures (GLB) and external files (GLTF)\n5. Handle node hierarchy â†’ Transform parent/child\n6. Store animation data for future Animation System",
          "labels": ["Feature", "Engine", "High Priority"]
        },
        {
          "name": "Animation System",
          "desc": "Implement skeletal animation support.\n\nCurrently static meshes only. Blocks any game with animated characters.\n\nImplementation:\n1. Add Skeleton component (bone hierarchy, bind poses)\n2. Add Animator component (clips, playback state, blending)\n3. Create AnimationClip asset (keyframes per bone: position, rotation, scale)\n4. Implement bone matrix calculation (local â†’ world, with parent chain)\n5. Upload bone matrices to GPU (UBO or SSBO)\n6. Add skinning in vertex shader (weighted blend of bone transforms)\n7. Support blend trees / state machines (later)",
          "labels": ["Feature", "Engine", "High Priority"]
        },
        {
          "name": "External Asset Importer",
          "desc": "Implement OS-level drag-and-drop for importing external assets from the file system.\n\nNote: Internal drag-drop (Asset Browser â†’ Scene Hierarchy/Material Editor) is ALREADY COMPLETE.\n\nRemaining Work:\n1. Register GLFW drop callback to detect files dropped from OS file explorer.\n2. Copy source files to the project `assets/` directory (organize by type: `assets/models`, `assets/textures`).\n3. Generate a `.meta` file for each asset containing a stable UUID and import settings.\n4. Refresh the Asset Browser to show newly imported files.",
          "labels": ["Editor", "Medium Priority"]
        }
      ]
    },
    {
      "name": "Done",
      "cards": [
        {
          "name": "Frustum Culling (CPU)",
          "desc": "Implemented CPU-side frustum culling for instanced rendering in RenderSystem.\n\nCompleted:\n1. Extract 6 frustum planes from view-projection matrix using `Frustum.fromViewProjection()`.\n2. Store AABB bounds in Mesh assets (min/max corners from geometry bounds).\n3. Transform AABB to world space using entity Transform with optimized `AABB.transform()` (fully unrolled loop).\n4. Test AABB against frustum planes using `Frustum.testAABB()` with compile-time `inline for`.\n5. Skip adding instances to render batches if AABB is fully outside frustum.\n\nOptimizations Applied:\n- All hot-path math functions inlined (`AABB.transform`, `Frustum.testAABB`, `Plane.distanceToPoint`).\n- Matrix comparison optimized with `inline for` loop unrolling.\n- Direct memcpy to GPU-mapped instance buffer (no intermediate ArrayList).\n- Frustum pre-validated once per frame, not per-mesh.\n- Added `AABB.boundingSphereRadius()` and `Frustum.testAABBWithSphere()` for potential sphere pre-test.\n\nFiles Modified:\n- `engine/src/utils/math.zig`: AABB, Frustum, Plane optimizations\n- `engine/src/ecs/systems/render_system.zig`: Culling integration, buffer upload optimization",
          "labels": ["Optimization", "Engine"]
        },
        {
          "name": "Editor Camera Separation",
          "desc": "Separated the Editor camera from the Game camera.\n\nCompleted:\n1. `CameraController` now has helper methods `getViewMatrix()`, `getInverseViewMatrix()`, `getPosition()` using YXZ Euler angles matching Camera.setViewYXZ.\n2. `SceneLayer.prepare()` handles camera switching based on scene state (Edit vs Play).\n3. In Edit mode: Uses CameraController's matrices directly.\n4. In Play mode: Uses scene's active Camera component.\n5. Removed redundant camera overrides from EditorApp.\n6. Fixed viewport camera mismatch that caused incorrect AABB calculations.",
          "labels": ["Feature", "Editor"]
        },
        {
          "name": "Fix Path Tracing Toggle Crash",
          "desc": "Fixed race condition when toggling path tracing mode.\n\nRoot Cause:\n- Render thread's `end()` called `applyPendingPathTracingToggle()` which set `compiled = false`.\n- Main thread's `prepareExecute()` checked `compiled` flag simultaneously.\n- Race condition caused crashes or undefined behavior.\n\nFix:\n- Moved path tracing toggle from render thread's `end()` to main thread's `prepare()` in SceneLayer.\n- All render graph state modifications now happen on main thread before render thread executes.",
          "labels": ["Bug Fix", "Engine"]
        },
        {
          "name": "Fix Play/Stop Texture Loading Crash",
          "desc": "Fixed crash when stopping Play mode due to same race condition as PT toggle.\n\nRoot Cause:\n- Same threading issue where render graph recompilation conflicted with render thread execution.\n\nFix:\n- Same fix as PT toggle - state changes moved to main thread's prepare phase.",
          "labels": ["Bug Fix", "Engine"]
        },
        {
          "name": "Add Script Execution Error Logging",
          "desc": "Added warning logs when Lua script execution fails.\n\nPreviously scripts failed silently with `catch {}`. Now logs:\n- 'Failed to run one-shot script: {error}'\n- 'Failed to enqueue update script: {error}'\n\nHelps debug broken user scripts.",
          "labels": ["Improvement", "Engine"]
        },
        {
          "name": "Scripting Integration",
          "desc": "Fully integrated the Lua scripting subsystem with comprehensive game API.\n\nCompleted:\n1. Entity API: create, destroy, exists, find, get/set name\n2. Transform API: position, rotation, scale, translate, rotate, look_at, direction vectors\n3. Input API: keyboard keys, mouse buttons, mouse position with Key.* constants\n4. Time API: delta time, elapsed time, frame count\n5. Light API: color, intensity, range for PointLights\n6. Particles API: rate, color, active state for ParticleEmitters\n7. Physics API: get/set velocity, add_force, add_impulse via Jolt\n8. Math API: vec3, distance, lerp, clamp, normalize, dot, cross\n9. Scene API: get current scene name\n10. Console & CVar APIs: logging, commands, configuration\n\nDocumentation: docs/SCRIPTING_API.md",
          "labels": ["Engine", "High Priority"]
        },
        {
          "name": "Play Mode",
          "desc": "Implemented the Editor state machine to toggle between 'Edit' and 'Play' modes.\n\nCompleted:\n1. Added `EditorState` enum (`Edit`, `Play`, `Paused`) to `EditorApp`.\n2. On Play: Serialize the current scene to an in-memory buffer using `SceneSerializer`.\n3. Start the game loop logic (physics, scripts, particles).\n4. On Stop: Clear the current scene and deserialize from the in-memory buffer to restore the exact state before gameplay.\n5. Disable Editor gizmos and selection during Play mode.",
          "labels": ["Editor", "High Priority"]
        },
        {
          "name": "Performance Pass",
          "desc": "Profiled and optimized engine subsystems.\n\nCompleted:\n1. Work-stealing job queue for ThreadPool\n2. Physics System optimization using views\n3. ECS query iteration improvements\n4. Memory allocation reduction in hot paths",
          "labels": ["Engine", "Optimization", "High Priority"]
        },
        {
          "name": "Work-stealing job queue",
          "desc": "Implemented a work-stealing scheduler for `ThreadPool` in `threading/thread_pool.zig`. Includes per-worker PRNG for efficient stealing and accurate queue size tracking.",
          "labels": ["Optimization", "Engine"]
        },
        {
          "name": "Physics System Optimization (Views)",
          "desc": "Optimized `PhysicsSystem` to use `world.view()` for component access instead of repeated `world.get()` calls, reducing hash map lookups during the update loop.",
          "labels": ["Optimization", "Engine"]
        },
        {
          "name": "Fix Shutdown Crash (Vulkan Validation)",
          "desc": "Resolved Vulkan validation errors and crashes on shutdown by correcting the deinitialization order of `FileWatcher`, `ThreadPool`, and `Engine` subsystems.",
          "labels": ["Bug Fix", "Engine"]
        },
        {
          "name": "Fix Editor Persistence (Lights)",
          "desc": "Fixed an issue where lights created in the Editor persisted after stopping Play mode. Updated `EditorApp` to use `scene.spawnEmpty` for proper lifecycle management.",
          "labels": ["Bug Fix", "Editor"]
        },
        {
          "name": "Physics Integration",
          "desc": "Integrate a physics engine (likely `zphysics` / Jolt Physics).\n\nImplementation Details:\n1. Add Jolt/PhysX bindings to `build.zig`.\n2. Create `PhysicsSystem` in `engine/src/ecs/systems/`.\n3. Define `RigidBody` (mass, friction, restitution) and `Collider` (Box, Sphere, Capsule, Mesh) components.\n4. In `PhysicsSystem.init`, initialize the physics world.\n5. In `PhysicsSystem.update`, copy ECS `Transform` to Physics Bodies (for kinematic/static) and copy Physics Bodies back to ECS `Transform` (for dynamic).\n6. Handle collision events and dispatch them.",
          "labels": ["Engine", "High Priority"]
        },
        {
          "name": "Physics System Cleanup & Stability",
          "desc": "Implemented orphan detection to clean up Jolt physics bodies when entities are destroyed or components are removed. Updated ECS Query system to support EntityId retrieval and added compile-time validation for queries.",
          "labels": ["Engine", "Physics", "Bug Fix"]
        },
        {
          "name": "Refactor Add Component UI",
          "desc": "Refactored `addComponentMenuItem` to be a shared helper, reducing code duplication between Inspector and Scene Hierarchy context menus.",
          "labels": ["Editor", "Refactor"]
        },
        {
          "name": "Material & Render System Stability Fixes",
          "desc": "Resolved Vulkan validation errors during cleanup (double frees on arena buffers). Fixed `updateGlobalSet` in MaterialSystem to correctly aggregate material sets for ray tracing. Implemented robust instance buffer reallocation in RenderSystem.",
          "labels": ["Bug Fix", "Engine"]
        },
        {
          "name": "Material Editor",
          "desc": "Implement a dedicated Editor window for creating and modifying materials with deep ECS integration.\n\n### Objective\nCreate a robust, user-friendly interface for editing PBR material properties in real-time.\n\n### UI Layout & Features\n1. **Header**:\n   - Material Name (editable text field).\n   - Shader Variant Selector (Dropdown: Opaque, Transparent, Cutout).\n2. **Albedo Section**:\n   - Color Picker (RGBA, supports HDR).\n   - Texture Slot (Drag-and-drop target for texture assets).\n   - Tiling & Offset fields (Vec2).\n3. **Surface Properties**:\n   - **Roughness**: Slider (0.0 - 1.0) + Texture Slot.\n   - **Metallic**: Slider (0.0 - 1.0) + Texture Slot.\n   - **Normal Map**: Texture Slot + Strength Slider.\n   - **Occlusion**: Texture Slot + Strength Slider.\n   - **Emissive**: HDR Color Picker + Texture Slot + Intensity Multiplier.\n4. **Component Management**:\n   - If a material component (e.g., `EmissiveMaterial`) is missing, show an 'Enable Emissive' button.\n   - 'Save Material' button to serialize current settings to a `.mat` JSON file.\n\n### Technical Implementation\n- **File**: Create `editor/src/windows/material_editor.zig`.\n- **Selection Handling**: Subscribe to Editor selection state. On selection, query the entity for `MaterialSet` and all property components (`AlbedoMaterial`, `RoughnessMaterial`, etc.).\n- **Texture Slots**: Implement `drawTextureSlot(label: []const u8, current_id: AssetId)`. Use `ImGui.image` for preview and `ImGui.beginDragDropTarget` to accept `ASSET_PATH` payloads.\n- **ECS Integration**: UI widgets must directly mutate ECS component data. The `MaterialSystem` will automatically detect dirty components and upload new data to the GPU buffers next frame.\n- **Asset Browser Integration**: Ensure dragging a texture from the Asset Browser into a slot correctly resolves the Asset ID.",
          "labels": ["Editor", "High Priority"]
        },
        {
          "name": "Fix Scene Hierarchy Parenting",
          "desc": "Resolved issues with parent-child relationships not persisting or displaying correctly.\n\n- Fixed `Transform.deserialize` to correctly resolve parent UUIDs to runtime Entity IDs.\n- Updated `SceneSerializer` to use correct UUID formatting.\n- Verified hierarchy visualization in the Scene Hierarchy Panel.",
          "labels": ["Bug Fix", "Editor"]
        },
        {
          "name": "Component Inspector Dropdown",
          "desc": "Allow adding components to entities via the Inspector.\n\nRequirements:\n1. Add a dropdown menu 'Add Component' to the Inspector panel.\n2. List available components (MeshRenderer, PointLight, Script, etc.).\n3. On selection, add the component to the selected entity.",
          "labels": ["Editor", "Feature"]
        },
        {
          "name": "Scene Hierarchy Context Menu",
          "desc": "Implement right-click context menu in the Scene Hierarchy Panel.\n\nRequirements:\n1. Right-click in open space -> 'Add Entity' (parented to scene root).\n2. Right-click on an existing entity -> 'Add Entity' (parented to that entity).",
          "labels": ["Editor", "Feature"]
        },
        {
          "name": "Editor: Add Save/Load Menu Items",
          "desc": "Add 'Save Scene' and 'Load Scene' to the main menu bar in the Editor UI (`editor/src/main.zig` or `editor_app.zig`).\n\nImplementation Details:\n1. Integrate a file dialog library (e.g., `nfd-zig` or `nativefiledialog`) to get absolute paths.\n2. In the `File` menu, call `nfd.saveDialog` / `nfd.openDialog` filtering for `.json`.\n3. On success, call `self.scene.save(path)` or `self.scene.load(path)`.\n4. Handle errors (e.g., file permission, invalid JSON) and show an error popup via `ImGui.openPopup`.",
          "labels": ["Editor"]
        },
        {
          "name": "Scene Serialization (Save/Load)",
          "desc": "Implement JSON serialization for Scene and GameObjects to enable persistent world building. See docs/SCENE_SERIALIZATION_DESIGN.md for details.",
          "labels": ["Feature", "High Priority"]
        },
        {
          "name": "Create SceneSerializer Struct",
          "desc": "Define serialize(scene, writer) and deserialize(scene, reader).",
          "labels": ["Implementation"]
        },
        {
          "name": "Implement Serialize Interface for Components",
          "desc": "Create mixin/interface for components to define jsonSerialize/jsonDeserialize.",
          "labels": ["Implementation"]
        },
        {
          "name": "Implement Transform Serialization",
          "desc": "Serialize Position, Rotation (Quat), Scale. Handle Parent-Child relationships (store parent's persistent ID).",
          "labels": ["Implementation"]
        },
        {
          "name": "Implement MeshRenderer Serialization",
          "desc": "Serialize model_asset (AssetId -> Path), texture_asset (AssetId -> Path), flags.",
          "labels": ["Implementation"]
        },
        {
          "name": "Implement Material System Serialization",
          "desc": "Serialize MaterialSet, AlbedoMaterial, RoughnessMaterial, MetallicMaterial, NormalMaterial, EmissiveMaterial.",
          "labels": ["Implementation"]
        },
        {
          "name": "Implement PointLight Serialization",
          "desc": "Serialize color, intensity, radius.",
          "labels": ["Implementation"]
        },
        {
          "name": "Implement Name Serialization",
          "desc": "Serialize entity name string.",
          "labels": ["Implementation"]
        },
        {
          "name": "Implement Scene.save()",
          "desc": "Iterate entities, collect components, write JSON.",
          "labels": ["Implementation"]
        },
        {
          "name": "Implement Scene.load()",
          "desc": "Clear scene, parse JSON, re-create entities, re-link hierarchy (2-pass), request assets.",
          "labels": ["Implementation"]
        },
        {
          "name": "Define Scene File Format (JSON)",
          "desc": "Design JSON schema. Decide on Entity ID handling (runtime vs persistent UUIDs) and Asset ID handling (paths vs UUIDs).",
          "labels": ["Design"]
        },
        {
          "name": "Implement UuidComponent",
          "desc": "Create UuidComponent and update Scene spawn methods to attach it.",
          "labels": ["Implementation"]
        },
        {
          "name": "Asset Management: Path Lookup",
          "desc": "Ensure AssetManager can return file path for AssetId (for saving) and AssetId for file path (for loading).",
          "labels": ["Engine"]
        },
        {
          "name": "Multi-component Queries",
          "desc": "Implemented complex ECS queries with `World.query(struct { ... })`.\n\nCompleted:\n- `QueryIterator` in `engine/src/ecs/query.zig` supports any struct with component pointer fields.\n- Required components drive iteration, optional components (nullable pointers) are fetched if present.\n- EntityId field support for getting the entity being iterated.\n- Compile-time validation ensures at least one required component.\n- Used throughout codebase: PhysicsSystem, RenderSystem, etc.\n\nExample:\n```zig\nvar query = try world.query(struct {\n    entity: EntityId,\n    transform: *Transform,\n    mesh: *MeshRenderer,\n    light: ?*PointLight,  // optional\n});\nwhile (query.next()) |item| { ... }\n```",
          "labels": ["Feature", "Engine"]
        },
        {
          "name": "Mesh Deduplication for Instancing",
          "desc": "Implemented instanced rendering with mesh deduplication in RenderSystem.\n\nCompleted:\n- `BatchBuilder` groups entities by MeshId and MaterialSetId.\n- `InstancedBatch` struct holds mesh pointer, instance count, and instance buffer offset.\n- Single `vkCmdDrawIndexedIndirect` per batch with `instanceCount > 1`.\n- Instance data (model matrix, normal matrix) uploaded to GPU SSBO.\n- Material sets further partition batches for correct descriptor binding.\n- Frustum culling integrated at batch build time.\n\nFiles:\n- `engine/src/ecs/systems/render_system.zig`: BatchBuilder, uploadInstanceBufferFromBatches()\n- `engine/src/rendering/render_data_types.zig`: InstancedBatch struct\n- `engine/src/rendering/passes/geometry_pass.zig`: Instanced draw calls",
          "labels": ["Optimization", "Engine"]
        },
        {
          "name": "Asset Streaming System",
          "desc": "Implemented async asset loading with background streaming.\n\nCompleted:\n- `AssetLoader` in `engine/src/assets/asset_loader.zig` handles background loading.\n- `loadAssetAsync()` queues load requests with priority levels.\n- ThreadPool workers process load queue in parallel.\n- Staging buffers used for GPU upload to avoid frame stutters.\n- Asset state tracking (Unloaded, Loading, Loaded, Failed).\n- Hot reload integration via FileWatcher.\n\nFiles:\n- `engine/src/assets/asset_manager.zig`: loadAssetAsync(), AssetLoader integration\n- `engine/src/assets/asset_loader.zig`: Background loading implementation\n- `engine/src/threading/thread_pool.zig`: Worker thread management",
          "labels": ["Feature", "Engine"]
        },
        {
          "name": "Tonemapping Pass",
          "desc": "Implemented HDR to LDR tonemapping as final render pass.\n\nCompleted:\n- `TonemapPass` in render graph converts HDR geometry buffer to LDR swapchain.\n- Configurable tonemapping curve (ACES, Reinhard, etc.).\n- Proper resource dependencies declared for execution ordering.\n\nFiles:\n- `engine/src/rendering/passes/tonemap_pass.zig`\n- `assets/shaders/tonemap.frag`",
          "labels": ["Feature", "Engine"]
        }
      ]
    },
    {
      "name": "Technical Debt",
      "cards": [
        {
          "name": "Move BLAS ownership to Mesh/Geometry",
          "desc": "Refactor BLAS (Bottom-Level Acceleration Structure) ownership.\n\nDetails:\n- Currently, BLAS are stored in a global registry.\n- Move `VkAccelerationStructureKHR` and `VkBuffer` handles into the `Mesh` or `Geometry` struct in `rendering/geometry.zig`.\n- Update `GeometryPass` to bind these directly from the Mesh asset.\n- This improves encapsulation and lifetime management of ray tracing resources.",
          "labels": ["Refactor", "High Priority"]
        },
        {
          "name": "Remove global BLAS registry",
          "desc": "Remove the global BLAS registry in `multithreaded_bvh_builder.zig` once ownership is moved to Meshes. This eliminates a global state bottleneck and simplifies the `RenderSystem`.",
          "labels": ["Refactor", "High Priority"]
        },
        {
          "name": "Archetype-based storage optimization",
          "desc": "Optimize ECS storage in `ecs/world.zig`.\n\nDetails:\n- Move from `SparseSet` per component to Archetypes (grouping entities by component composition).\n- This improves cache locality for systems iterating over specific component sets (e.g., `Transform` + `MeshRenderer`).",
          "labels": ["Optimization", "Medium Priority"]
        },
        {
          "name": "Comprehensive asset validation",
          "desc": "Add validation logic to `asset_manager.zig`.\n\nDetails:\n- Check file integrity (magic numbers, checksums).\n- Validate format versions.\n- Check dependencies (e.g., material textures exist).\n- Log detailed errors for broken assets instead of crashing.",
          "labels": ["Maintenance", "Medium Priority"]
        },
        {
          "name": "Automatic shader variant generation",
          "desc": "Automate shader variant generation in `shader_compiler.zig`.\n\nDetails:\n- Instead of manually defining permutations, generate them based on material usage.\n- E.g., generate variants for: `HAS_NORMAL_MAP`, `HAS_EMISSIVE`, `SKINNED`, `STATIC`.\n- Compile these variants offline or on-demand.",
          "labels": ["Feature", "Medium Priority"]
        }
      ]
    },
    {
      "name": "Backlog - Rendering",
      "cards": [
        {
          "name": "Occlusion Culling (GPU)",
          "desc": "Implement GPU-side occlusion culling.\n\nDetails:\n- Use Hi-Z buffer generation (downsample depth buffer).\n- Use Compute Shader to check object AABBs against Hi-Z buffer.\n- Generate indirect draw commands for visible objects.",
          "labels": ["Optimization"]
        },
        {
          "name": "Distance-based LOD",
          "desc": "Implement a Level of Detail (LOD) system.\n\nDetails:\n- Import multiple mesh variants (LOD0, LOD1, LOD2).\n- In `RenderSystem`, calculate distance from camera.\n- Select appropriate mesh variant based on distance thresholds.",
          "labels": ["Optimization"]
        },
        {
          "name": "Volumetric Light Scattering",
          "desc": "Implement volumetric lighting (God rays).\n\nDetails:\n- Raymarch through shadow maps in a post-process shader.\n- Or use screen-space radial blur from the light source position.",
          "labels": ["Feature"]
        },
        {
          "name": "Post-processing Pipeline",
          "desc": "Implement a post-processing stack.\n\nDetails:\n- Bloom: Threshold -> Downsample -> Blur -> Upsample -> Combine.\n- FXAA: Fast Approximate Anti-Aliasing pass.\n\nNote: Tonemapping is ALREADY COMPLETE (TonemapPass in render graph).",
          "labels": ["Feature"]
        }
      ]
    },
    {
      "name": "Backlog - Editor",
      "cards": [
        {
          "name": "Selection System",
          "desc": "Implement multi-entity selection in the Editor.\n\nDetails:\n- Update `SelectionContext` to hold `ArrayList(EntityId)`.\n- Render selection outlines: Render selected entities to a stencil buffer or separate color attachment, then edge-detect in post-process.",
          "labels": ["Feature"]
        }
      ]
    },
    {
      "name": "Backlog - ECS & Systems",
      "cards": [
        {
          "name": "Event System for Components",
          "desc": "Implement an event system for components.\n\nDetails:\n- Components can trigger events (e.g., `OnCollision`, `OnDestroy`).\n- Systems can subscribe to these events.\n- Use a message bus or observer pattern within the ECS.\n\nNote: CollisionEvent already exists in PhysicsSystem - this is about generalizing it.",
          "labels": ["Feature"]
        },
        {
          "name": "Prefab System",
          "desc": "Implement Prefabs.\n\nDetails:\n- Define a Prefab asset format (JSON).\n- `PrefabManager` loads and caches prefabs.\n- `Scene.instantiate(prefab_id)` spawns entities and copies components from the prefab template.",
          "labels": ["Feature"]
        }
      ]
    },
    {
      "name": "Backlog - Assets",
      "cards": [
        {
          "name": "Compressed Texture Support",
          "desc": "Support loading and rendering compressed texture formats.\n\nDetails:\n- Support BC7 (high quality) and ASTC (mobile/efficient).\n- Update `TextureManager` to handle block-compressed data upload.\n- Reduces VRAM usage significantly.",
          "labels": ["Feature"]
        },
        {
          "name": "Asset Bundles",
          "desc": "Implement asset packaging/bundles.\n\nDetails:\n- Pack multiple assets into single binary files (e.g., `.pak`).\n- Include a header/directory for fast lookup.\n- Reduces OS file handle overhead and improves load times.",
          "labels": ["Feature"]
        }
      ]
    }
  ]
}
